# k grid for the sigma2 integral
log10_k_min_sigma2: -4
log10_k_max_sigma2: 0.5
k_steps_sigma2: 10_000  # this must be dense because of the bessel functions
k_steps_romb_sigma2: 16_385  # same as above, but with a 2**k + 1 points for romberg integration (in this case 8192 + 1)

# 2d z grid on which to compute sigma2
z_min_sigma2: 0.001
z_max_sigma2: 3.
z_steps_sigma2: 3000
sigma2_integrating_function: 'romb'

use_precoumputed_sigma2: False
save_sigma2: True
plot_sigma2: True

# z grid for the other quantites which enter the ssc integral (which are then interpolated)
z_min_interm_quantities: 0.01
z_max_interm_quantities: 3.
z_steps_interm_quantities: 700  # this should be high! maybe 10_000?

# z grid for the ssc integral
z_min_sscintegral: 0.01
z_max_sscintegral: 3.
z_steps_sscintegral: 100

n_samples_wf: 1000

sky_area_deg2: 14700
zbins: 10
nbl: 20
ell_min: 10
ell_max: 3000
ell_grid_recipe: 'ISTF'

use_h_units: false
triu_tril: 'triu'
row_col_major: 'row-major'

# cl settings
bias_model: 'step-wise'

# ! these are specific to PyCCL, for a fair comparison of the results
probes: [ '3x2pt', ]
which_NGs: [ 'SSC', ]
save_covs: true
GL_or_LG: 'GL'
get_3xtpt_cov_in_4D: true  # whether to output the 3x2pt non-gaussian (SSC or cNG) covariance in 4D or as a 10d dict
test_against_benchmarks: false